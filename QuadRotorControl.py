# -*- coding: utf-8 -*-
"""LowLevelControl.ipynb

Automatically generated by Colaboratory.

import numpy as np
from numpy.linalg import inv
import matplotlib.pyplot as plt
from scipy.integrate import odeint
from numpy import sin, cos, arctan
from scipy.optimize import nnls

from PyDiffGame import PyDiffGame


def quad_rotor_state_diff_eqn_for_given_pqrT(X, t, p, q, r, T, Plast):
    Ixx = 7.5e-3
    Iyy = 7.5e-3
    Izz = 1.3e-2
    m = 0.65
    l = 0.23
    Jr = 6e-5
    g = 9.81
    b = 3.13e-5
    d = 7.5e-7

    a1 = (Iyy - Izz) / Ixx
    a2 = Jr / Ixx
    a3 = (Izz - Ixx) / Iyy
    a4 = Jr / Iyy
    a5 = (Ixx - Iyy) / Izz

    b1 = l / Ixx
    b2 = l / Iyy
    b3 = 1 / Izz

    phi, dPhidt, theta, dThetadt, psi, dPsidt, z, dzdt, x, dxdt, y, dydt = X
    u_x = cos(phi) * sin(theta) * cos(psi) + sin(phi) * sin(psi)
    u_y = cos(phi) * sin(theta) * sin(psi) - sin(phi) * cos(psi)

    K = cos(phi) * cos(theta) / m
    U = low_level_angular_rate_controller([dPhidt, dThetadt, dPsidt], p, q, r, T, Plast)
    omegas_squared_coeffs = np.array([[b] * 4,
                                      [0, -b, 0, b],
                                      [b, 0, -b, 0],
                                      [-d, d, -d, d]
                                      ])
    u1, u2, u3, u4 = U
    omegas_squared = nnls(omegas_squared_coeffs, np.array([u1, u2, u3, u4]))[0]
    # omegas_squared = nnls(omegas_squared_coeffs, [u1[0],u2[0],u3[0],u4[0]])[0]

    omegas = np.sqrt(omegas_squared)

    # u1, u2, u3, u4 = U
    u5 = d * (omegas[0] - omegas[1] + omegas[2] - omegas[3])

    dPhiddt = dThetadt * (dPsidt * a1 + u5 * a2) + b1 * u2
    dThetaddt = dPhidt * (dPsidt * a3 - u5 * a4) + b2 * u3
    dPsiddt = dThetadt * dPhidt * a5 + b3 * u4
    # print(K)
    dzddt = g - K * u1
    dxddt = u_x * u1 / m
    dyddt = u_y * u1 / m

    return np.array([dPhidt, dPhiddt, dThetadt, dThetaddt, dPsidt, dPsiddt, dzdt,
                     dzddt, dxdt, dxddt, dydt, dyddt], dtype='float64')


def low_level_angular_rate_controller(x, p, q, r, T, Plast):
    M = 3
    P_size = M ** 2
    N = 3
    Ixx = 7.5e-3
    Iyy = 7.5e-3
    Izz = 1.3e-2
    m = 0.65
    g = 9.81
    l = 0.23
    Jr = 6e-5

    a1 = (Iyy - Izz) / Ixx
    a2 = Jr / Ixx
    a3 = (Izz - Ixx) / Iyy
    a4 = Jr / Iyy
    a5 = (Ixx - Iyy) / Izz

    b1 = l / Ixx
    b2 = l / Iyy
    b3 = 1 / Izz

    A = np.array([[0, (1 / 2) * a1 * x[2], (1 / 2) * a1 * x[1]],
                  [(1 / 2) * a3 * x[2], 0, (1 / 2) * a3 * x[0]],
                  [(1 / 2) * a5 * x[1], (1 / 2) * a5 * x[0], 0]])

    B1 = np.array([[b1],
                   [0],
                   [0]])

    B2 = np.array([[0],
                   [b2],
                   [0]])

    B3 = np.array([[0],
                   [0],
                   [b3]])

    Q1 = np.array([[1000, 0, 0],
                   [0, 10, 0],
                   [0, 0, 10]])

    Q2 = np.array([[10, 0, 0],
                   [0, 1000, 0],
                   [0, 0, 10]])

    Q3 = np.array([[10, 0, 0],
                   [0, 10, 0],
                   [0, 0, 1000]])

    R1 = np.array([[0.1]])
    R2 = np.array([[0.1]])
    R3 = np.array([[0.1]])

    B = [B1, B2, B3]
    R = [R1, R2, R3]
    Q = [Q1, Q2, Q3]
    # P_sol = Q
    # P = solve_diff_game(A=A, B=B, Q=Q, R=R,P_f=P_sol,cl=True, show_legend=False)
    # Plast=P[-1]
    P_sol = Plast
    reduced_X = np.array(x) - np.array([p, q, r])
    reduced_X_tr = reduced_X.T
    inv_Rs = [inv(r) for r in R]
    B_t = [b.T for b in B]
    U_angular = np.array([- r @ b @ p @ reduced_X_tr for r, b, p in zip(inv_Rs, B_t, P_sol)]).reshape(3, )
    u2, u3, u4 = U_angular
    U = [T, u2, u3, u4]
    # print(U)

    return U


def get_P_quad_given_angular_rates(x, P_sol):
    M = 3
    P_size = M ** 2
    N = 3
    Ixx = 7.5e-3
    Iyy = 7.5e-3
    Izz = 1.3e-2
    m = 0.65
    l = 0.23
    Jr = 6e-5

    a1 = (Iyy - Izz) / Ixx
    a2 = Jr / Ixx
    a3 = (Izz - Ixx) / Iyy
    a4 = Jr / Iyy
    a5 = (Ixx - Iyy) / Izz

    b1 = l / Ixx
    b2 = l / Iyy
    b3 = 1 / Izz

    A = np.array([[0, (1 / 2) * a1 * x[2], (1 / 2) * a1 * x[1]],
                  [(1 / 2) * a3 * x[2], 0, (1 / 2) * a3 * x[0]],
                  [(1 / 2) * a5 * x[1], (1 / 2) * a5 * x[0], 0]])

    B1 = np.array([[b1],
                   [0],
                   [0]])

    B2 = np.array([[0],
                   [b2],
                   [0]])

    B3 = np.array([[0],
                   [0],
                   [b3]])

    Q1 = np.array([[1000, 0, 0],
                   [0, 10, 0],
                   [0, 0, 10]])

    Q2 = np.array([[10, 0, 0],
                   [0, 1000, 0],
                   [0, 0, 10]])

    Q3 = np.array([[10, 0, 0],
                   [0, 10, 0],
                   [0, 0, 1000]])

    R1 = np.array([[0.1]])
    R2 = np.array([[0.1]])
    R3 = np.array([[0.1]])

    B = [B1, B2, B3]
    R = [R1, R2, R3]
    Q = [Q1, Q2, Q3]

    P = PyDiffGame(A=A, B=B, Q=Q, R=R, P_f=P_sol, cl=True, show_legend=False).play_the_game()
    # P = solve_diff_game(A=A, B=B, Q=Q, R=R, P_f=P_sol, cl=True, show_legend=False)
    Plast = P[-1]

    return Plast


def get_mf_numerator(F3, R11, F1, R31, a_y, R12, R32):
    return F3 * R11 - F1 * R31 + a_y * (R12 * R31 - R11 * R32)


def get_mf_denominator(F2, R11, F1, R21, a_y, R22, R12):
    return - F2 * R11 + F1 * R21 + a_y * (R11 * R22 - R12 * R21)


def get_mc_numerator(mf_numerator, a_z, R31, R13, R11, R33):
    return mf_numerator + a_z * (R13 * R31 - R11 * R33)


def get_mc_denominator(mf_denominator, a_z, R11, R23):
    return mf_denominator - a_z * R11 * R23


def hpf_ode_v_d_s(v_d_s, t, f_a, f_b, P_z_tilda):
    return f_a * v_d_s + f_b * P_z_tilda


def hpf_ode_h_d_s(h_d_s, t, f_a, f_b, P_y_tilda):
    return f_a * h_d_s + f_b * P_y_tilda


v_d_s_0 = 0
h_d_s_0 = 0


def get_higher_level_control(state, st, a_y):
    global v_d_s_0, h_d_s_0
    m = 0.65
    g = 9.81
    # a_y = 1
    a_z = -2.5

    x = state[8]
    y = state[10]
    z = state[6]
    phi = state[0]
    theta = state[2]
    psi = state[4]

    stheta = sin(theta)
    ctheta = cos(theta)
    spsi = sin(psi)
    cpsi = cos(psi)
    sphi = sin(phi)
    cphi = cos(phi)
    sectheta = 1 / ctheta
    tanpsi = spsi / cpsi

    vp_x = sectheta * (sphi * stheta - cphi * tanpsi)
    vp_y = sectheta * (- cphi * stheta - sphi * tanpsi)

    R11 = ctheta * cpsi
    R21 = cpsi * stheta * sphi - cphi * spsi
    R31 = cpsi * stheta * cphi + sphi * spsi
    R12 = ctheta * spsi
    R22 = spsi * stheta * sphi + cphi * cpsi
    R32 = spsi * stheta * cphi - sphi * cpsi
    R13 = - stheta
    R23 = ctheta * sphi
    R33 = ctheta * cphi
    r = np.array([[R11, R21, R31], [R12, R22, R32], [R13, R23, R33]])

    curr_loc = np.array([[x], [y], [z]])
    [F1, F2, F3] = r.T @ curr_loc

    mfr_numerator = get_mf_numerator(F3, R11, F1, R31, a_y, R12, R32)
    mfr_denominator = get_mf_denominator(F2, R11, F1, R21, a_y, R22, R12)
    mfl_numerator = get_mf_numerator(F3, R11, F1, R31, -a_y, R12, R32)
    mfl_denominator = get_mf_denominator(F2, R11, F1, R21, -a_y, R22, R12)

    mfr = mfr_numerator / mfr_denominator
    mfl = mfl_numerator / mfl_denominator

    mcr = get_mc_numerator(mfr_numerator, a_z, R31, R13, R11, R33) / get_mc_denominator(mfr_denominator, a_z, R11, R23)
    mcl = get_mc_numerator(mfl_numerator, a_z, R31, R13, R11, R33) / get_mc_denominator(mfl_denominator, a_z, R11, R23)

    at_mcl = arctan(mcl)
    at_mcr = arctan(mcr)
    at_mfl = arctan(mfl)
    at_mfr = arctan(mfr)

    p_y_tilda = at_mcl + at_mcr - at_mfl - at_mfr
    p_z_tilda = at_mfl - at_mfr + at_mcl - at_mcr
    phi_tilda = at_mfl + at_mfr + at_mcl + at_mcr

    f_a = -10
    f_b = 8
    f_c = -12.5
    f_d = 10

    v_d_s = v_d_s_0
    h_d_s = h_d_s_0
    v_d = f_c * v_d_s + f_d * p_z_tilda
    h_d = f_c * h_d_s + f_d * p_y_tilda

    data_points = 100
    t = np.linspace(st, st + 0.1, data_points)
    v_d_s = np.mean(odeint(func=hpf_ode_v_d_s, y0=v_d_s_0, t=t, args=(f_a, f_b, p_z_tilda)))
    h_d_s = np.mean(odeint(func=hpf_ode_h_d_s, y0=h_d_s_0, t=t, args=(f_a, f_b, p_y_tilda)))

    v_d_s_0 = v_d_s
    h_d_s_0 = h_d_s

    k_p = -10
    k_phi = 0.5
    k_phi_d = -0.05
    k_z = -1
    k_z_d = -0.6
    k_theta = 3
    k_psi = 6
    p_r = -k_p * phi_tilda + k_phi * p_y_tilda - k_phi_d * h_d
    q_r = k_theta * vp_y
    r_r = k_psi * vp_x
    t_r = k_z * (p_z_tilda) + k_z_d * v_d + m * g

    tilda_state = np.array([phi_tilda[0], vp_y, vp_x, p_y_tilda[0], h_d[0], p_z_tilda[0], v_d[0]])
    return p_r, q_r, r_r, t_r, tilda_state


v_d_s_0 = 0
h_d_s_0 = 0


def calculate_Bs(u_sizes, dividing_matrix, B):
    block_matrix = B @ dividing_matrix
    Bs = []

    last = 0
    for u_size in u_sizes:
        Bs += [block_matrix[:, last:u_size + last]]
        last = u_size

    return Bs


def wall_punishment(wall_distance, a_y):
    return 3 * (10 ** 2) * (wall_distance / a_y) ** 2


def get_higher_level_control2(state, st, a_y):
    global v_d_s_0, h_d_s_0, sum_theta
    m = 0.65
    g = 9.81
    # a_y = 1
    a_z = -2.5

    x = state[8]
    y = state[10]
    z = state[6]
    phi = state[0]
    theta = state[2]
    psi = state[4]

    stheta = sin(theta)
    ctheta = cos(theta)
    spsi = sin(psi)
    cpsi = cos(psi)
    sphi = sin(phi)
    cphi = cos(phi)
    sectheta = 1 / ctheta
    tanpsi = spsi / cpsi

    vp_x = sectheta * (sphi * stheta - cphi * tanpsi)
    vp_y = sectheta * (- cphi * stheta - sphi * tanpsi)

    R11 = ctheta * cpsi
    R21 = cpsi * stheta * sphi - cphi * spsi
    R31 = cpsi * stheta * cphi + sphi * spsi
    R12 = ctheta * spsi
    R22 = spsi * stheta * sphi + cphi * cpsi
    R32 = spsi * stheta * cphi - sphi * cpsi
    R13 = - stheta
    R23 = ctheta * sphi
    R33 = ctheta * cphi
    r = np.array([[R11, R21, R31], [R12, R22, R32], [R13, R23, R33]])

    curr_loc = np.array([[x], [y], [z]])
    [F1, F2, F3] = r.T @ curr_loc

    mfr_numerator = get_mf_numerator(F3, R11, F1, R31, a_y, R12, R32)
    mfr_denominator = get_mf_denominator(F2, R11, F1, R21, a_y, R22, R12)
    mfl_numerator = get_mf_numerator(F3, R11, F1, R31, -a_y, R12, R32)
    mfl_denominator = get_mf_denominator(F2, R11, F1, R21, -a_y, R22, R12)

    mfr = mfr_numerator / mfr_denominator
    mfl = mfl_numerator / mfl_denominator

    mcr = get_mc_numerator(mfr_numerator, a_z, R31, R13, R11, R33) / get_mc_denominator(mfr_denominator, a_z, R11, R23)
    mcl = get_mc_numerator(mfl_numerator, a_z, R31, R13, R11, R33) / get_mc_denominator(mfl_denominator, a_z, R11, R23)

    at_mcl = arctan(mcl)
    at_mcr = arctan(mcr)
    at_mfl = arctan(mfl)
    at_mfr = arctan(mfr)

    p_y_tilda = at_mcl + at_mcr - at_mfl - at_mfr
    p_z_tilda = at_mfl - at_mfr + at_mcl - at_mcr
    phi_tilda = at_mfl + at_mfr + at_mcl + at_mcr

    f_a = -10
    f_b = 8
    f_c = -12.5
    f_d = 10

    v_d_s = v_d_s_0_2
    h_d_s = h_d_s_0_2
    v_d = f_c * v_d_s + f_d * p_z_tilda
    h_d = f_c * h_d_s + f_d * p_y_tilda

    data_points = 100
    t = np.linspace(st, st + 0.1, data_points)
    v_d_s = np.mean(odeint(func=hpf_ode_v_d_s, y0=v_d_s_0_2, t=t, args=(f_a, f_b, p_z_tilda)))
    h_d_s = np.mean(odeint(func=hpf_ode_h_d_s, y0=h_d_s_0_2, t=t, args=(f_a, f_b, p_y_tilda)))

    v_d_s_0_2 = v_d_s
    h_d_s_0_2 = h_d_s
    sum_theta = sum_theta + vp_y * 0.1

    Q1 = np.array([[1000, 0, 0, 0, 0, 0, 0],
                   [0, 1000, 0, 0, 0, 0, 0],
                   [0, 0, 1000, 0, 0, 0, 0],
                   [0, 0, 0, 0.1, 0, 0, 0],
                   [0, 0, 0, 0, 0.1, 0, 0],
                   [0, 0, 0, 0, 0, 10, 0],
                   [0, 0, 0, 0, 0, 0, 0.05]])

    R1 = np.array([[10, 0, 0, 0],
                   [0, 10, 0, 0],
                   [0, 0, 10, 0],
                   [0, 0, 0, 0.01]])

    A = np.array([[0, 0, 0, 0, 0, 0, 0],
                  [0, 0, 0, 0, 0, 0, 0],
                  [0, 0, 0, 0, 0, 0, 0],
                  [0, 0, 0, 0, 1, 0, 0],
                  [g, 0, 0, 0, 0, 0, 0],
                  [0, 0, 0, 0, 0, 0, 1],
                  [0, 0, 0, 0, 0, 0, 0]])

    B = np.array([[1, 0, 0, 0],
                  [0, 1, 0, 0],
                  [0, 0, 1, 0],
                  [0, 0, 0, 0],
                  [0, 0, 0, 0],
                  [0, 0, 0, 0],
                  [0, 0, 0, -1 / m]])

    dividing_matrix = np.array([[1, 0, 0, 0, 0, 0],
                                [0, 1, 0, 0, 1, 1],
                                [0, 0, 1, 0, 0, 0],
                                [0, 0, 0, 1, 0, 0]])

    u_sizes = [4, 1, 1]
    Bs = calculate_Bs(u_sizes, dividing_matrix, B)

    Q2 = np.array([[0, 0, 0, 0, 0, 0, 0],
                   [0, 3 * (10 ** 2), 0, 0, 0, 0, 0],
                   [0, 0, 0, 0, 0, 0, 0],
                   [0, 0, 0, 0, 0, 0, 0],
                   [0, 0, 0, 0, 0, 0, 0],
                   [0, 0, 0, 0, 0, 0, 0],
                   [0, 0, 0, 0, 0, 0, 0]])

    R2 = np.array([[10]])

    max_punishment = wall_punishment(a_y, a_y)
    curr_punishment = min(max_punishment, wall_punishment(p_y_tilda[0], a_y))

    Q3 = np.array([[0, 0, 0, 0, 0, 0, 0],
                   [0, curr_punishment, 0, 0, 0, 0, 0],
                   [0, 0, 0, 0, 0, 0, 0],
                   [0, 0, 0, 0, 0, 0, 0],
                   [0, 0, 0, 0, 0, 0, 0],
                   [0, 0, 0, 0, 0, 0, 0],
                   [0, 0, 0, 0, 0, 0, 0]])

    R3 = np.array([[10]])

    R = [R1, R2, R3]
    Q = [0.01 * Q1, 0.01 * Q2, 0.01 * Q3]
    P_sol = [0.01 * Q1, 0.01 * Q2, 0.01 * Q3]

    Psol = PyDiffGame(A=A, B=Bs, Q=Q, R=R, P_f=P_sol, cl=True, show_legend=False).play_the_game()

    # Psol = solve_diff_game(A=A, B=Bs, Q=Q, R=R, P_f=P_sol, cl=True, show_legend=False)
    Plast = Psol[-1]
    N = 3
    M = 7
    P_size = M ** 2
    Plast = [(Plast[i * P_size:(i + 1) * P_size]).reshape(M, M) for i in range(N)]

    inv_Rs = [inv(r) for r in R]
    B_t = [b.T for b in Bs]
    U_Agenda1 = - inv_Rs[0] @ B_t[0] @ Plast[0] @ np.array(
        [-phi_tilda[0], -vp_y, -vp_x, -p_y_tilda[0], -h_d[0], -p_z_tilda[0], -v_d[0]])
    U_Agenda2 = - inv_Rs[1] @ B_t[1] @ Plast[1] @ np.array(
        [-phi_tilda[0], - ((sum_theta + 0.1) - vp_y), -vp_x, -p_y_tilda[0], -h_d[0], -p_z_tilda[0], -v_d[0]])
    U_Agenda3 = - inv_Rs[2] @ B_t[2] @ Plast[2] @ np.array(
        [-phi_tilda[0], - ((sum_theta) - vp_y), -vp_x, -p_y_tilda[0], -h_d[0], -p_z_tilda[0], -v_d[0]])

    Us = [U_Agenda1, U_Agenda2, U_Agenda3]

    U_all_Out = dividing_matrix @ np.concatenate(Us).ravel().T
    p_r, q_r, r_r, t_r = U_all_Out

    tilda_state = np.array([phi_tilda[0], vp_y, vp_x, p_y_tilda[0], h_d[0], p_z_tilda[0], v_d[0]])
    return p_r, q_r, r_r, t_r + m * g, tilda_state


if __name__ == '__main__':

    Q1 = np.array([[1000, 0, 0],
                   [0, 10, 0],
                   [0, 0, 10]])
    Q2 = np.array([[10, 0, 0],
                   [0, 1000, 0],
                   [0, 0, 10]])
    Q3 = np.array([[10, 0, 0],
                   [0, 10, 0],
                   [0, 0, 1000]])
    Q = [Q1, Q2, Q3]

    M = 3
    P_size = M ** 2
    N = 3

    tTotal_low = [0]
    a_ys = [0.5, 0.75, 1]

    quad_rotor_state_PD_dynamic = {}
    quad_rotor_state_PD_dynamic_low = {}

    plt.figure(dpi=130)

    deltaTstate = 0.1
    X_rotor_0 = np.array([0.1, 0, 0.1, 0, 0.1, 0, -1, 0, 0, 0, 0.4, 0])

    for j, a_y in enumerate(a_ys):
        quad_rotor_state_PD_dynamic[j] = [X_rotor_0]
        quad_rotor_state_PD_dynamic_low[j] = [X_rotor_0]
        tilda_state = np.array([0, 0, 0, 0, 0, 0, 0])
        tilda_state_dynamic = [tilda_state]
        T_start = 0
        tTotal = [0]

        X_rotor_0_PD = X_rotor_0
        Plast = [Q1, Q2, Q3]
        v_d_s_0 = 0
        h_d_s_0 = 0
        sum_theta = 0

        for i in range(200):
            # high-level control

            p_r, q_r, r_r, t_r, tilda_state_l = get_higher_level_control(X_rotor_0_PD, T_start, a_y)
            p_r2, q_r2, r_r2, t_r2, tilda_state_l2 = get_higher_level_control2(X_rotor_0_PD, T_start, a_y)

            tilda_state = [tilda_state_l]
            tilda_state_dynamic = np.append(tilda_state_dynamic, tilda_state, axis=0)
            T_end = T_start + deltaTstate
            data_points = 100
            t = np.linspace(T_start, T_end, data_points)

            # low-level control
            curr_x = [X_rotor_0_PD[1], X_rotor_0_PD[3], X_rotor_0_PD[5]]
            Plast = get_P_quad_given_angular_rates(curr_x, Plast)
            Plast = [(Plast[i * P_size:(i + 1) * P_size]).reshape(M, M) for i in range(N)]
            quad_rotor_state_PD = odeint(quad_rotor_state_diff_eqn_for_given_pqrT, X_rotor_0_PD, t,
                                         args=(p_r2, q_r2, r_r2, t_r2, Plast))
            X_rotor_0_PD = quad_rotor_state_PD[-1]
            T_start = T_end
            quad_rotor_state_PD_dynamic[j] = np.append(quad_rotor_state_PD_dynamic[j],
                                                       quad_rotor_state_PD, axis=0)
            quad_rotor_state_PD_dynamic_low[j] = np.append(quad_rotor_state_PD_dynamic_low[j],
                                                           [X_rotor_0_PD], axis=0)
            if j == 0:
                tTotal = np.append(tTotal, t)
                tTotal_low = np.append(tTotal_low, T_end)

        plt.plot(tTotal_low[1:], quad_rotor_state_PD_dynamic_low[j][1:, 9])

    plt.grid()
    plt.legend([str(curr_a_y) for curr_a_y in a_ys])
    plt.show()

    for var in quad_rotor_state_PD_dynamic_low:
        plt.figure(dpi=130)
        plt.plot(tTotal_low[1:], var[1:, 0])
        plt.plot(tTotal_low[1:], -tilda_state_dynamic[1:, 0])
        plt.legend(['$\\phi$', '$\\tilde{\\phi}$'])
        plt.grid()
        plt.show()

    plt.figure(dpi=130)
    plt.plot(tTotal_low[1:], quad_rotor_state_PD_dynamic_low[1:, 2])
    plt.plot(tTotal_low[1:], -tilda_state_dynamic[1:, 1])
    # plt.plot(tTotal_low[1:], -tilda_state_dynamic2[1:,1])
    # plt.legend(['$\\theta$', '$\\tilde{\\theta}$', '$\\tilde{\\theta}2$'])
    plt.legend(['$\\theta$', '$\\tilde{\\theta}$'])
    plt.grid()
    plt.show()

    plt.figure(dpi=130)
    plt.plot(tTotal_low[1:], quad_rotor_state_PD_dynamic_low[1:, 4])
    plt.plot(tTotal_low[1:], -tilda_state_dynamic[1:, 2])
    # plt.plot(tTotal_low[1:], -tilda_state_dynamic2[1:,2])
    # plt.legend(['$\\psi$', '$\\tilde{\\psi}$', '$\\tilde{\\psi}2$'])
    plt.legend(['$\\psi$', '$\\tilde{\\psi}$'])
    plt.grid()
    plt.show()

    plt.figure(dpi=130)
    plt.plot(tTotal_low[1:], quad_rotor_state_PD_dynamic_low[1:, 6])
    plt.plot(tTotal_low[1:], -(tilda_state_dynamic[1:, 5]))
    # plt.plot(tTotal_low[1:], -(tilda_state_dynamic2[1:,5]))
    # plt.legend(['$z$', '$\\tilde{z}$', '$\\tilde{z}2$'])
    plt.legend(['$z$', '$\\tilde{z}$'])
    plt.grid()
    plt.show()
    print(quad_rotor_state_PD_dynamic_low[-1, 6])

    plt.figure(dpi=130)
    plt.plot(tTotal_low[1:], quad_rotor_state_PD_dynamic_low[1:, 10])
    plt.plot(tTotal_low[1:], tilda_state_dynamic[1:, 3])
    # plt.plot(tTotal_low[1:], -tilda_state_dynamic2[1:,3])
    # plt.legend(['$y$', '$\\tilde{y}$', '$\\tilde{y}2$'])
    plt.legend(['$y$', '$\\tilde{y}$'])
    plt.grid()
    plt.show()

    plt.figure(dpi=130)
    plt.plot(tTotal_low[1:], quad_rotor_state_PD_dynamic_low[1:, 11])
    plt.plot(tTotal_low[1:], tilda_state_dynamic[1:, 4])
    # plt.plot(tTotal_low[1:], -tilda_state_dynamic2[1:,4])
    # plt.legend(['$\\dot{y}$', '$h_d$', '$h_d2$'])
    plt.legend(['$\\dot{y}$', '$h_d$'])
    plt.grid()
    plt.show()

    plt.figure(dpi=130)
    plt.plot(tTotal_low[1:], quad_rotor_state_PD_dynamic_low[1:, 7])
    plt.plot(tTotal_low[1:], -tilda_state_dynamic[1:, 6])
    # plt.plot(tTotal_low[1:], -tilda_state_dynamic2[1:,6])
    # plt.legend(['$\\dot{z}$', '$v_d$', '$v_d2$'])
    plt.legend(['$\\dot{z}$', '$v_d$', '$v_d2$'])
    plt.grid()
    plt.show()

    print(quad_rotor_state_PD_dynamic_low[-1, 9])
    plt.figure(dpi=130)
    plt.plot(tTotal_low[1:], quad_rotor_state_PD_dynamic_low[1:, 9])
    # plt.plot(tTotal_low[1:], -tilda_state_dynamic2[1:,6])
    # plt.legend(['$\\dot{z}$', '$v_d$', '$v_d2$'])
    plt.legend(['$\\dot{x}$', '$v_d$', '$v_d2$'])
    plt.grid()
    plt.show()
